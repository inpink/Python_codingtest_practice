
백준 2573번(bfs)
https://www.acmicpc.net/problem/2573

- for문을 쓰는 함수 중간에서 return하는 것 주의하자.  ⭐️️마지막 반복에서 count>=2같은 조건 만족할 수도 있다. ⭐️
아래는 틀린 코드.
```
def isSeparate(g):

  visited=[[False for j in range(m)] for i in range(n)]

  count=0
  for startX in range(1,n-1):
    for startY in range(1,m-1):
      if g[startX][startY]==0 or visited[startX][startY]:
        continue
      if count>=2: ⭐️bad
        return True

      q=deque([])
      q.append((startX,startY))
      visited[startX][startY]=True

      while True:
        if len(q)==0:
          break

        x,y=q.popleft()

        for moveX,moveY in dir:
          nextX=x+moveX
          nextY=y+moveY

          if g[nextX][nextY]==0:
            continue
          if visited[nextX][nextY]:
            continue

          visited[nextX][nextY]=True
          q.append((nextX,nextY))
      count+=1

  # print(count)
  return False
```

아래는 좋은 코드
```

def isSeparate(g):

  visited=[[False for j in range(m)] for i in range(n)]

  count=0
  for startX in range(1,n-1):
    if count>=2: #⭐️
      break
    for startY in range(1,m-1):
      if g[startX][startY]==0 or visited[startX][startY]:
        continue
      if count>=2: #⭐️
        break

      q=deque([])
      q.append((startX,startY))
      visited[startX][startY]=True

      while True:
        if len(q)==0:
          break

        x,y=q.popleft()

        for moveX,moveY in dir:
          nextX=x+moveX
          nextY=y+moveY

          if g[nextX][nextY]==0:
            continue
          if visited[nextX][nextY]:
            continue

          visited[nextX][nextY]=True
          q.append((nextX,nextY))
      count+=1

  # print(count)
  if count>=2: #⭐️
    return True
  else:
    return False
```


----------

###[dp]

> 백준 1082번(dp)

- dp는 열린 마음으로 보기
- dp[a] = 1~m원(a)으로 살 수 있는 """최대금액"""
- ⭐️string 정렬하기(temp가 str) : "".join(sorted(temp)   / "".join(sorted(temp, reverse=True) 역순정렬
- dp기본값에 None같은 건 두지 말기 (max계산같은거 복잡해서 무조건 꼬임)
- ⭐dp[a]값 갱신할 땐 dp[a]= max(dp[a], new_value) 이렇게 min이나 max 항상 두는 것 고려하기. 대부분의 경우에서 이게 필요함.
- dp[x]=-1을  기본값으로 뒀다면, dp[a]=dp[a-j]+i 요런 사칙연산 들어갈 때, 기본값(-1)이 영향 주지 않도록  if dp[money-cost]==-1: 같은 것 고려할 것
```
import sys
input = sys.stdin.readline

n=int(input())
costs=list(map(int,input().split()))
m=int(input())

dp = [-1 for i in range(m+1)]

for money in range(1,m+1): #money원으로 살 수 있는 최대 금액이 dp[money]다
  for j in range(n):
    cost=costs[j]

    if cost<=money: #6 13    7 13    13 13      6 21   7 21   8 21     1 3, 2 3, 3 3
      if dp[money-cost]==-1:
        dp[money] = max(dp[money],j)
      else:
        temp=str(j)+str(dp[money-cost])
        new_digit=int("".join(sorted(temp, reverse=True)))
        # print(money,new_digit, dp)
        dp[money]=max(dp[money], new_digit)

  # print(money,"(money)",dp)

print(max(dp))
```

----------

> 백준 1135번(dfs+dp)

- x점까지의 비용을 구하는 문제. x점 아래의 자식 노드가 k개이고 소요 시간이 다른데 점화식을 어떻게 세울지가 중요했던 문제.
- 4 3 2이 있다면, 4->3->2 순으로 방문하는 것이 유리하고, 각 방문 시  max( 4, (3+1), (2+2))이 걸린다.
- 4 4 3이 있다면, max( 4, 4+1, 3+2)이 걸린다.
- 바로 위 예제에서, 4+ 1+ 1이 아니다.  max(4, 4+1, 3+2)다. 4+1으로 max값이 갱신됐다면, 3번째 것이 5초 걸린다해도 총 4+1초만 걸리면 된다.
```
def calculate(candidates):
  candidates.sort(reverse=True)

  maxCandi=max(candidates)

  count=maxCandi
  for i in range(1,len(candidates)):
    if i+candidates[i]>maxCandi:
      count+=i+candidates[i]-maxCandi
      maxCandi=max(maxCandi, i+candidates[i]) # ⭐
  return count
  ```
------

> 백준 2098번 (외판원순환, dfs+dp+비트마스킹)

- 외판원순환이란, 1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시 사이에는 길이 있을 수 있다.
- 모든 도시를 "한 번씩만" 거치는 사이클의 최소 탐색 비용을 구하는 문제이다.
 (이를 '어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는' 이라고 표현하지만, *결국 한 사이클이라 어디서 출발해도 상관없다*)
- 비트마스킹을 써야하는 이유! dp[x][visited]를 만들어야하는데, n=16일 때 비트마스킹으로는 10000000000000000(2), 65536(10)만 있으면 된다.
  비트마스킹 없으면 위 dp 구조론 사실상 불가능
- dp없이 dfs&백트래킹 or brute force는 어떨까? n=9일 때, _ _ _ _ _ _ _ _ _ 여기 들어갈 순서를 고르는 거니까 시간복잡도가 9!이다. 따라서 n이 작으면 가능하다. (9!=약36만, 16!=무지하게 큼)

- 1<<16 하면 2진수로는 10000000000000000 지만, 출력결과는 10진수인 65536임
-  (1<<n) -1:  ⭐ 연산자 우선순위 -가 더 높아서 " 1<<n -1" 으로 하면 1<<(n-1)으로 취급된다! 괄호로 묶기
- 소수점x번째 자리에서 버리기: 아래 예시는 16번째자리에서 버림
  ```
  import math
  ans = math.trunc(value * 10**15) / 10**15 #value가 원본 소수임
  ```

- 외판원순환 코드(dfs+dp+비트마스킹)는 아래를 참고. 아직 어느정돈 외웠음
- dp기본값을 MAX_VALUE로 두면 안된다. 길이없어서 MAX_VALUE인지, 아직 가본적이 없어서 MAX_VALUE인지 알 수 없기 때문에 가지치기가 덜된다.
- dp[x][visited(2)]는, 현재 x에 있으며 visited를 방문했을 때의 최소 비용
- 정답은 결국 print(dp[0][1])이 된다. dp[0][1111(2)]을 구하는게아니라 왜 dp[0][1]이 정답이 될까?
  dp[0][111..1] =  “이미 모든 도시를 방문한 상태에서 현재 도시가 0”, 	이 경우 “앞으로 방문할 도시가 없다”
  dp[0][1]은 “출발 직후 상태 → 앞으로 모든 도시를 방문하고 돌아오는 최적 비용”이라서 최종 답.
- visited | (1<<i)는  새로운 도시 i를 방문했다고 표시하는 연산. |는 비트별로 OR 연산.  i=3이라면 1<<i == 1000(2), visited가 0100(2)였다면 1100이 됨
```
MAX_VALUE=10**8
n = int(input()) #4일 때
graph = []
for i in range(n):
  graph.append(list(map(int, input().split())))

# 1<<16 하면 2진수로는 10000000000000000 지만, 출력결과는 10진수인 65536임
dp=[[-1 for i in range(1<<n)] for i in range(n)] #dp[x][visited(2)]는, 현재 x에 있으며 visited를 방문했을 때의 최소 비용
def dfs(x, visited):
  # for a in dp:
  #   print(a)
  if visited == int('1'*n,2): # 1<<n -1도 됨 # 모든 도시 방문함
    if graph[x][0]!=0: #출발점으로 돌아갈 수 있다면
      return graph[x][0]
    else:
      return MAX_VALUE

  if dp[x][visited]!=-1: # 이미 최소 비용을 구했다면
    return dp[x][visited]

  for i in range(n): #x -> i  모든 도시 방문
    if graph[x][i]==0: #방문할 수 없는 도시라면 패스
      continue
    if visited & 1 << i: #이미 방문했던 도시라면 패스 (한 번만 방문할 수 있다는 조건이 있고, dp에 담긴 값은 (x,visited) 중 가장 효율적인 값이다.)
      continue

    # dp 점화식, visited | (1<<i)는  새로운 도시 i를 방문했다고 표시하는 연산. |는 비트별로 OR 연산.  i=3이라면 1<<i == 1000(2), visited가 0100(2)였다면 1100이 됨
    if dp[x][visited]== -1: #아직 한 번도 탐색하지 않은 (x,visited)이기에 min을 두면 기본값인 -1에 걸려서 업데이트가 안된다. 따라서 min없이 탐색시킨 값을 무저건 넣어준다
      dp[x][visited] = dfs(i, visited | (1<<i)) + graph[x][i]
    else: #이미 탐색했다면 더 효율적인(더 작은)값을 담는다. 여기 걸리는 경우는, for문 안에서 위의 if문이 걸린 다음이다. 즉, 다른 i방문보다 더 효율적이면 dp를 갱신한다.
      dp[x][visited] = min(dp[x][visited], dfs(i, visited | (1<<i)) + graph[x][i])

  if dp[x][visited] == -1: #모든 도시 방문을 시도했는데도 -1이라면 "못간 것"이다.
    return MAX_VALUE #길이 없는 경우에만 MAX_VALUE를 반환해서 안간 것과 못간 것을 구분하기로 했다

  return dp[x][visited] #결국 정답은 dp[x][0]이 된다.

print(dfs(0, 1)) #0, 0001
```


------

> 백준 5601번 (dp, 수학)

- 전체 그래프(또는 dp 행렬)에 대해 특정 열/행만 전처리를 해줬다면, **전처리에 문제 없는지 꼼꼼히 확인**하자.
  예를 들어 1번째 행과 1번째 줄에 벽이 있는 경우 무조건 1이 아니다.
- (참고) dfs나 백트래킹 안되는 이유! 시간복잡도=> 최대 가로로 16줄, 세로로 16줄이 있다. 오른쪽으로 15번,	위쪽으로 15번 움직이면 도착이에요. 총 이동 횟수는 30번뿐입니다.
   시간 복잡도는 선택지 2개 × 30번 = 2^{30}이 아니라, 30번 중에 순서 상관없이 15번을 위로, 15번을 오른쪽으로 고르는 조합 ⭐️30! / (15! × 15!)⭐️ 다.


------

### [stack]

> 백준 1918번 (스택)

- 솔직히 다는 모르겠고 주석 참고 ㄱㄱ하고 어느정돈 외웠음
```
import sys
input = sys.stdin.readline

s=input().rstrip()

stack=[]
ans=""
for c in s:
  if c.isalpha():
    ans+=c
  else:
    if c=="(":
      stack.append(c)
    elif c=="+" or c=="-": # + -를 만났으면 새로운 구분이 열리는거라 이전에 우선순위가 높은 것들( * / + -)을 다 끝내준다. (는 아직 끝나지 않은거라 냅둠
      while True:
        if len(stack)==0:
          break
        if stack[-1]=="(":
          break
        ans+=stack.pop()
      stack.append(c)
    elif c=="*" or c=="/": # 같은 구분인  * / 이 앞에 있으면 바로 ans에 담아준다. 그외에 것들은 다음 구분에서 처리하도록 stack에 담는다
      while True:
        if len(stack)==0:
          break
        if stack[-1]!="*" and stack[-1]!="/":
          break
        ans+=stack.pop()
      stack.append(c)
    elif c==")":
      while True:
        if len(stack)==0:
          break
        if stack[-1]=="(":
          stack.pop()
          break
        ans+=stack.pop()
  # print(c, ans, stack)

while True: # 남은 것 ans에 그대로 담기
  if len(stack)==0:
    break
  ans+=stack.pop()

print(ans)

```


---

###[그리디]

> 백준 2437번 (그리디)

- 아이디어가 없으면 못풀고, 코드는 엄청 간단한 그리디 문제.
- 주석 참고

```
import sys
input = sys.stdin.readline

n=int(input())
weights=list(map(int,input().split()))
weights.sort() #정렬 꼭 필요
ans = 0 #지금까지 만들 수 있는 숫자의 최댓값

for number in weights:
  if number>ans+1: #새로운 숫자가 지금까지 만들 수 있는 숫자보다 2이상 크면, 1개 이상의 간극이 생기는 것이기에 ans+1이 정답임
    break

  ans+=number


print(ans+1) #정답 = 만들 수 없는 최솟값  = 지금까지 만들 수 있는 숫자의 최댓값 + 1
```

--------

> 백준 3109번 (그리디)

- 그래프에서 "대각선 이동"되는지 문제 잘 읽자. 처음에 대각선 이동 되는거 못봐서 문제 이해 못했음
- 그래프에서도 "그리디"일 수 있다는 가정을 하고 문제를 보자.
  - 그러면 이게 보인다. "최대한의 파이프를 만들려면 -> 하나의 파이프는, 특정 y줄에서 딱 한 칸만 먹는 것이 유리하다. ⭐대각선 이동이 가능하기 때문이다!!⭐
   그리고, 시작 y줄은 다 비어있기 때문이다. 하나의 파이프가 같은 y줄에서 2칸 차지해버리면 불필요하게 가능성을 막는 것이다. 즉, 비어있는 한 칸에 올 수 있는 효율적인 이전 칸은 정해져있다."
  - 즉, 맨 위에서부터 탐색하고, (오른대각위, 바로 오른 옆, 오른대각아래) 순서대로 가능한걸 먼저 가는 dfs하면 그만이다.
- 구현은 간단함 걍 dfs. 최대한의 파이프를 만들어야 하니까 1개라도 맨 끝 y줄 다다랐다면 바로 1 return하는 거만 주의하면 됨.
A x x . A
B A x A B
. B A B .
. . B x .
. . . x .

```
dir = [(-1, 1), (0,1), (1,1)] #대각상, 바로옆, 대각아래

def dfs(x,y):
  if y==m-1:
    return 1

  for dirX, dirY in dir:
    nextX=dirX+x
    nextY=dirY+y

    if nextX<0 or nextX>=n or nextY<0 or nextY>=m:
      continue
    if graph[nextX][nextY]!='x':
      graph[nextX][nextY]='x'
      ex = dfs(nextX, nextY)
      if ex==1:
        return 1

  return 0

count=0
for i in range(n):
  startX=i
  startY=0

  graph[startX][startY]='x'
  count+= dfs(startX, startY)
print(count)
```

--------

### [누적합]

### [비트마스킹]

> 백준 9527번 (누적 합, 비트 마스킹)

- n이라는 숫자를 2진수로 바꾸면 1또는 0이 몇 개 있을까? 를 세는 문제.
 우선 n을 2진수로 바꾸자.
  그리고, i번째 비트는 주기 = 2^(i+1)⭐, 그 안에  ⭐️1인 구간이 2^i개  ⭐️ 존재한다.
  	•	0번째 비트(맨 오른쪽)는 1,0,1,0… 이렇게 1,0이 번갈아 나타남 → 주기 2
  	•	1번째 비트는 0011, 0011… → 주기 4, 절반이 1
  	•	2번째 비트는 00001111… → 주기 8, 절반이 1
    ⭐이 주기는 0부터 세는 거다. ⭐
- 1개수를 세는 자세한 구현은 아래 코드 참고.

```
def ones_upto(n: int) -> int:
  """0..n 에서 '1' 비트 총합 (n<0이면 0)"""
  if n < 0:
    return 0
  total = 0
  # 10^16 < 2^54 이므로 0..56이면 충분
  for i in range(56): #i번째 비트에 1 몇개 있는지 세는거임
    block = 1 << (i + 1)   # 주기 길이, 2 ** (i + 1)도 됨
    half  = 1 << i         # 주기의 절반(해당 비트가 1인 구간 길이), 2**i도 됨, block/2도됨
    full_cycles = (n + 1) // block # (n+1)개 숫자 중에서 주기(block) 단위로 몇 번 완전히 반복되는지
    rem = (n + 1) % block  # 마지막에 남는 부분 (주기가 완전히 안 찬 나머지)
    total += full_cycles * half # 완전한 주기 부분에서는 각 주기마다 half개씩 1이 등장

    # 나머지(rem) 부분에서 추가로 생기는 1들 계산
    # rem이 half보다 크면, 그 초과 부분만큼 1이 더 있음 (주기는 0부터 세고, 0011 이런식으로 처음 절반만 0이기 때문!)

    if rem > half:
      total += (rem - half)
    # print(block, half, full_cycles,rem)
  return total


A, B = map(int, input().split())
print(ones_upto(B) - ones_upto(A - 1))
```

- 누적합
  10^16개 전부 계산하면 시간초과이므로 위와 같은 알고리즘 쓰고, (b까지의 개수 - a까지의 개수) 로 정답 구함

-----
