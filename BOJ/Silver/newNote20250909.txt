
백준 2573번(bfs)
https://www.acmicpc.net/problem/2573

- for문을 쓰는 함수 중간에서 return하는 것 주의하자.  ⭐️️마지막 반복에서 count>=2같은 조건 만족할 수도 있다. ⭐️
아래는 틀린 코드.
```
def isSeparate(g):

  visited=[[False for j in range(m)] for i in range(n)]

  count=0
  for startX in range(1,n-1):
    for startY in range(1,m-1):
      if g[startX][startY]==0 or visited[startX][startY]:
        continue
      if count>=2: ⭐️bad
        return True

      q=deque([])
      q.append((startX,startY))
      visited[startX][startY]=True

      while True:
        if len(q)==0:
          break

        x,y=q.popleft()

        for moveX,moveY in dir:
          nextX=x+moveX
          nextY=y+moveY

          if g[nextX][nextY]==0:
            continue
          if visited[nextX][nextY]:
            continue

          visited[nextX][nextY]=True
          q.append((nextX,nextY))
      count+=1

  # print(count)
  return False
```

아래는 좋은 코드
```

def isSeparate(g):

  visited=[[False for j in range(m)] for i in range(n)]

  count=0
  for startX in range(1,n-1):
    if count>=2: #⭐️
      break
    for startY in range(1,m-1):
      if g[startX][startY]==0 or visited[startX][startY]:
        continue
      if count>=2: #⭐️
        break

      q=deque([])
      q.append((startX,startY))
      visited[startX][startY]=True

      while True:
        if len(q)==0:
          break

        x,y=q.popleft()

        for moveX,moveY in dir:
          nextX=x+moveX
          nextY=y+moveY

          if g[nextX][nextY]==0:
            continue
          if visited[nextX][nextY]:
            continue

          visited[nextX][nextY]=True
          q.append((nextX,nextY))
      count+=1

  # print(count)
  if count>=2: #⭐️
    return True
  else:
    return False
```


----------

백준 1082번(dp)

- dp는 열린 마음으로 보기
- dp[a] = 1~m원(a)으로 살 수 있는 """최대금액"""
- ⭐️string 정렬하기(temp가 str) : "".join(sorted(temp)   / "".join(sorted(temp, reverse=True) 역순정렬
- dp기본값에 None같은 건 두지 말기 (max계산같은거 복잡해서 무조건 꼬임)
- ⭐dp[a]값 갱신할 땐 dp[a]= max(dp[a], new_value) 이렇게 min이나 max 항상 두는 것 고려하기. 대부분의 경우에서 이게 필요함.
- dp[x]=-1을  기본값으로 뒀다면, dp[a]=dp[a-j]+i 요런 사칙연산 들어갈 때, 기본값(-1)이 영향 주지 않도록  if dp[money-cost]==-1: 같은 것 고려할 것
```
import sys
input = sys.stdin.readline

n=int(input())
costs=list(map(int,input().split()))
m=int(input())

dp = [-1 for i in range(m+1)]

for money in range(1,m+1): #money원으로 살 수 있는 최대 금액이 dp[money]다
  for j in range(n):
    cost=costs[j]

    if cost<=money: #6 13    7 13    13 13      6 21   7 21   8 21     1 3, 2 3, 3 3
      if dp[money-cost]==-1:
        dp[money] = max(dp[money],j)
      else:
        temp=str(j)+str(dp[money-cost])
        new_digit=int("".join(sorted(temp, reverse=True)))
        # print(money,new_digit, dp)
        dp[money]=max(dp[money], new_digit)

  # print(money,"(money)",dp)

print(max(dp))
```

----------

백준 1135번(dfs+dp)

- x점까지의 비용을 구하는 문제. x점 아래의 자식 노드가 k개이고 소요 시간이 다른데 점화식을 어떻게 세울지가 중요했던 문제.
- 4 3 2이 있다면, 4->3->2 순으로 방문하는 것이 유리하고, 각 방문 시  max( 4, (3+1), (2+2))이 걸린다.
- 4 4 3이 있다면, max( 4, 4+1, 3+2)이 걸린다.
- 바로 위 예제에서, 4+ 1+ 1이 아니다.  max(4, 4+1, 3+2)다. 4+1으로 max값이 갱신됐다면, 3번째 것이 5초 걸린다해도 총 4+1초만 걸리면 된다.
```
def calculate(candidates):
  candidates.sort(reverse=True)

  maxCandi=max(candidates)

  count=maxCandi
  for i in range(1,len(candidates)):
    if i+candidates[i]>maxCandi:
      count+=i+candidates[i]-maxCandi
      maxCandi=max(maxCandi, i+candidates[i]) # ⭐
  return count
  ```

------

백준 1918번 (스택)

- 솔직히 다는 모르겠고 주석 참고 ㄱㄱ하고 어느정돈 외웠음
```
import sys
input = sys.stdin.readline

s=input().rstrip()

stack=[]
ans=""
for c in s:
  if c.isalpha():
    ans+=c
  else:
    if c=="(":
      stack.append(c)
    elif c=="+" or c=="-": # + -를 만났으면 새로운 구분이 열리는거라 이전에 우선순위가 높은 것들( * / + -)을 다 끝내준다. (는 아직 끝나지 않은거라 냅둠
      while True:
        if len(stack)==0:
          break
        if stack[-1]=="(":
          break
        ans+=stack.pop()
      stack.append(c)
    elif c=="*" or c=="/": # 같은 구분인  * / 이 앞에 있으면 바로 ans에 담아준다. 그외에 것들은 다음 구분에서 처리하도록 stack에 담는다
      while True:
        if len(stack)==0:
          break
        if stack[-1]!="*" and stack[-1]!="/":
          break
        ans+=stack.pop()
      stack.append(c)
    elif c==")":
      while True:
        if len(stack)==0:
          break
        if stack[-1]=="(":
          stack.pop()
          break
        ans+=stack.pop()
  # print(c, ans, stack)

while True: # 남은 것 ans에 그대로 담기
  if len(stack)==0:
    break
  ans+=stack.pop()

print(ans)

```