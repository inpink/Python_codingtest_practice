import sys
from collections import deque

input = sys.stdin.readline


'''
5시 5분
정사각형 4개를 이어 붙인 폴리오미노는 테트로미노, 총 5가지 종류가 있음
회전이나 대칭을 시켜도 된다. => 더 다양한 모양이 나옴
테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야함

가로크기 M(4~500) X 세로크기 N(4~500) paper가 주어짐
각 숫자는 최대 1000까지

모든 숫자를 다 검사하긴 해야함
=> 근접한 숫자들을 대상으로 검사해나가는 bfs가 유력
=> 최적의 해가 어디있을지 모르니까 brute force, 모든 조합을 구하면 시간초과니까 가지치기 잘해야함

나올 수 있는 테트로미노는 최대 40개지만, 노가다식으로 20개의 유형을 모두 정해주는 문제는 아닐것임
=>이 맞네.... 이렇게 해도 풀림
=> dfs+백트래킹이나 bfs로도 풀 수 있음. 모든 테트로미노는 2개의 연속되는 블럭이 있음. 연속되는 2개의 블럭을 정한 뒤 dfs/bfs(visited).
전체 graph를 모양별로 여러 번(25만*모양) 검사하는 것보다 전체 graph를 덜 도므로 시간적으로 20배정도 효율적

왼쪽, 위부터 시작하니까
갱신은 오른, 아래로 내려가는 방향만 됨
'''

# 입력
n,m = map(int, input().split())
paper = []
for i in range(n):
    paper.append(list(map(int, input().split())))

maxSum = 0
teterominos=[
[(0,0),(0,1),(0,2),(0,3)], #1
[(0,0),(1,0),(2,0),(3,0)],
[(0,0),(0,1),(1,0),(1,1)], #2
[(0,0),(1,0),(2,0),(2,1)], #3
[(0,1),(1,1),(2,1),(2,0)],
[(0,0),(0,1),(0,2),(1,0)],
[(0,0),(0,1),(0,2),(1,2)],
[(0,0),(0,1),(1,1),(2,1)],
[(0,0),(0,1),(1,0),(2,0)],
[(0,2),(1,0),(1,1),(1,2)],
[(0,0),(1,0),(1,1),(1,2)],
[(0,0),(1,0),(1,1),(2,1)], #4
[(0,1),(1,0),(1,1),(2,0)],
[(0,1),(0,2),(1,0),(1,1)],
[(0,0),(0,1),(1,1),(1,2)],
[(0,0),(0,1),(0,2),(1,1)], #5
[(0,1),(1,0),(1,1),(2,1)],
[(0,1),(1,0),(1,1),(1,2)],
[(0,0),(1,0),(2,0),(1,1)]
]



x,y=0,0

while (True):

    if (x==n):
        break
    for direction in teterominos:
        isPossible = True
        sumCandidate = 0
        for moveX,moveY in direction:
            if (x+moveX)>=n or (y+moveY)>=m:
                isPossible = False
                break
            sumCandidate+=paper[x+moveX][y+moveY]
                
        if isPossible:
            maxSum = max(maxSum,sumCandidate)
                            
        #print(maxSum)


    #다음 좌표로 이동
    if (y==m-1):
        x+=1
        y=0
    else:
        y+=1
        

print(maxSum)

